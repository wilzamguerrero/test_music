<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Oculta el botón VR -->
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    
    .a-enter-vr-button { display: none !important; }
    
    /* Estilos para la animación intro */
    #intro-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
      animation: fadeInOut 4s ease-in-out forwards;
      overflow: hidden;
    }
    
    #intro-image {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0;
      animation: fadeImage 3s ease-in-out forwards;
    }
    
    @keyframes fadeInOut {
      0% { opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { opacity: 0; display: none; }
    }
    
    @keyframes fadeImage {
      0% { opacity: 0; }
      30% { opacity: 1; }
      70% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Estilos para los botones de control */
    #control-buttons {
      position: fixed;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 20px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    .control-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 20px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }
    
    .control-btn:active {
      transform: scale(0.95);
    }

    #startButton {
      display: none;
    }
  </style>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.0.0/dist/aframe-extras.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  <!-- Font Awesome para íconos -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
  <!-- Animación de intro -->
  <div id="intro-container">
    <img id="intro-image" src="https://cdn.jsdelivr.net/gh/wilzamguerrero/test_music@main/assets/inicio.jpg" alt="Intro Animation">
  </div>

  <!-- Botones de control fijos -->
  <div id="control-buttons">
    <button id="play-pause-btn" class="control-btn"><i class="fas fa-pause"></i></button>
    <button id="restart-btn" class="control-btn"><i class="fas fa-redo"></i></button>
    <button id="mute-btn" class="control-btn"><i class="fas fa-volume-up"></i></button>
  </div>

  <a-scene
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: false"
    mindar-image="imageTargetSrc: https://cdn.jsdelivr.net/gh/wilzamguerrero/test_music@main/assets/targets.mind; filterMinCF: 0.001; filterBeta: 0.01;"
    color-space="sRGB"
    renderer="colorManagement: true, physicallyCorrectLights"
  >
    <a-assets>
      <!-- Videos -->
      <video id="video0"
             src="https://cdn.jsdelivr.net/gh/wilzamguerrero/test_music@main/assets/media.mp4"
             preload="auto" loop playsinline webkit-playsinline crossorigin="anonymous">
      </video>
      <video id="video1"
             src="https://cdn.jsdelivr.net/gh/wilzamguerrero/test_music@main/assets/media.mp4"
             preload="auto" loop playsinline webkit-playsinline crossorigin="anonymous">
      </video>
      
      <!-- Máscaras en blanco y negro (blanco = visible, negro = oculto) -->
      <img id="mask0" src="https://cdn.jsdelivr.net/gh/wilzamguerrero/test_music@main/assets/mask1.jpg" crossorigin="anonymous">
      <img id="mask1" src="https://cdn.jsdelivr.net/gh/wilzamguerrero/test_music@main/assets/mask1.jpg" crossorigin="anonymous">
      
      <!-- Imágenes PNG para marcos/overlays (delante del video) -->
      <img id="frame0" src="https://cdn.jsdelivr.net/gh/wilzamguerrero/test_music@main/assets/frame1.png" crossorigin="anonymous">
      <img id="frame1" src="https://cdn.jsdelivr.net/gh/wilzamguerrero/test_music@main/assets/frame1.png" crossorigin="anonymous">
    </a-assets>

    <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

    <!-- Marcador 0 -->
    <a-entity id="target0" mindar-image-target="targetIndex: 0">
      <!-- Video con máscara aplicada -->
      <a-video id="plane0" src="#video0" video-mask="mask: #mask0"></a-video>
      <!-- Imagen PNG delante del video (marco/overlay) -->
      <a-image id="overlay0" src="#frame0" material="transparent: true; alphaTest: 0.5"></a-image>
    </a-entity>

    <!-- Marcador 1 -->
    <a-entity id="target1" mindar-image-target="targetIndex: 1">
      <!-- Video con máscara aplicada -->
      <a-video id="plane1" src="#video1" video-mask="mask: #mask1"></a-video>
      <!-- Imagen PNG delante del video (marco/overlay) -->
      <a-image id="overlay1" src="#frame1" material="transparent: true; alphaTest: 0.5"></a-image>
    </a-entity>
  </a-scene>

  <div id="startButton" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); 
       background-color: rgba(0,0,0,0.5); color: white; padding: 10px 20px; border-radius: 5px; z-index: 999;">
  </div>

  <script>
    // Componente personalizado para aplicar máscara al video
    AFRAME.registerComponent('video-mask', {
      schema: {
        mask: { type: 'selector' }
      },

      init: function() {
        this.applyMask();
      },

      applyMask: function() {
        const el = this.el;
        const maskImg = this.data.mask;

        // Esperar a que la máscara se cargue
        if (maskImg.complete) {
          this.createMaskedMaterial();
        } else {
          maskImg.addEventListener('load', () => {
            this.createMaskedMaterial();
          });
        }
      },

      createMaskedMaterial: function() {
        const el = this.el;
        const maskImg = this.data.mask;
        
        // Crear textura de máscara
        const maskTexture = new THREE.Texture(maskImg);
        maskTexture.needsUpdate = true;

        // Esperar a que el material del video esté listo
        el.addEventListener('materialtextureloaded', () => {
          const videoTexture = el.getObject3D('mesh').material.map;
          
          // Crear material personalizado con máscara
          const maskedMaterial = new THREE.ShaderMaterial({
            uniforms: {
              videoTexture: { value: videoTexture },
              maskTexture: { value: maskTexture }
            },
            vertexShader: `
              varying vec2 vUv;
              void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            fragmentShader: `
              uniform sampler2D videoTexture;
              uniform sampler2D maskTexture;
              varying vec2 vUv;
              
              void main() {
                vec4 videoColor = texture2D(videoTexture, vUv);
                vec4 maskColor = texture2D(maskTexture, vUv);
                
                // Usar el canal rojo de la máscara como alfa
                // Blanco (1.0) = visible, Negro (0.0) = transparente
                float alpha = maskColor.r;
                
                gl_FragColor = vec4(videoColor.rgb, videoColor.a * alpha);
              }
            `,
            transparent: true
          });

          // Aplicar el material personalizado
          el.getObject3D('mesh').material = maskedMaterial;
        });
      }
    });

    // 1) Configuración de escala individual para videos, máscaras y overlays
    const configs = [
      { 
        vidId: 'video0', 
        planeId: 'plane0', 
        overlayId: 'overlay0',
        scaleFactor: 1.32,
        overlayScale: 1.4,        // Escala del marco/overlay (más grande que el video)
        overlayPositionZ: 0.05    // Posición Z del overlay (más cerca de la cámara = parallax)
      },
      { 
        vidId: 'video1', 
        planeId: 'plane1',
        overlayId: 'overlay1', 
        scaleFactor: 0.8,
        overlayScale: 1.2,        // Escala del marco/overlay
        overlayPositionZ: 0.08    // Posición Z del overlay (efecto parallax más pronunciado)
      }
    ];

    // Variable para seguir el video activo actualmente
    let activeVideoId = null;

    // 2) Al cargar metadatos, establecemos proporción y escalado
    configs.forEach(({ vidId, planeId, overlayId, scaleFactor, overlayScale, overlayPositionZ }) => {
      const vid = document.getElementById(vidId);
      const plane = document.getElementById(planeId);
      const overlay = document.getElementById(overlayId);

      vid.addEventListener('loadedmetadata', () => {
        const aspect = vid.videoWidth / vid.videoHeight;
        
        // Configurar VIDEO con máscara
        plane.setAttribute('width', aspect);
        plane.setAttribute('height', 1);
        plane.setAttribute('scale', `${scaleFactor} ${scaleFactor} ${scaleFactor}`);
        plane.setAttribute('position', `0 0 0.02`);
        
        // Configurar OVERLAY (imagen PNG delante)
        overlay.setAttribute('width', aspect);
        overlay.setAttribute('height', 1);
        overlay.setAttribute('scale', `${overlayScale} ${overlayScale} ${overlayScale}`);
        overlay.setAttribute('position', `0 0 ${overlayPositionZ}`);
      });
    });

    // 3) Sistema de suavizado para reducir vibraciones
    AFRAME.registerComponent('smooth-position', {
      schema: {
        factor: { type: 'number', default: 0.1 }
      },

      init: function() {
        this.targetPosition = new THREE.Vector3();
        this.smoothedPosition = new THREE.Vector3();
        
        this.el.addEventListener('targetFound', () => {
          this.smoothedPosition.copy(this.el.object3D.position);
        });
      },

      tick: function() {
        if (!this.el.object3D.visible) return;

        this.targetPosition.copy(this.el.object3D.position);
        this.smoothedPosition.lerp(this.targetPosition, this.data.factor);
        this.el.object3D.position.copy(this.smoothedPosition);
      }
    });

    // 4) Cuando la escena arranca, vinculamos comportamientos
    document.querySelector('a-scene').addEventListener('renderstart', () => {
      document.querySelectorAll('[mindar-image-target]').forEach(target => {
        target.setAttribute('smooth-position', 'factor: 0.1');
      });

      configs.forEach(({ vidId }, idx) => {
        const vid = document.getElementById(vidId);
        const targetEl = document.querySelector(`a-entity[mindar-image-target="targetIndex: ${idx}"]`);
        
        targetEl.addEventListener('targetFound', () => {
          vid.play();
          activeVideoId = vidId;
          updateButtonStates();
        });
        
        targetEl.addEventListener('targetLost', () => {
          vid.pause();
          if (activeVideoId === vidId) {
            activeVideoId = null;
          }
        });
      });
    });

    // Activar audio automáticamente sin botón
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        configs.forEach(({vidId}) => {
          const vid = document.getElementById(vidId);
          vid.muted = false;
        });
      }, 1000);
    });

    // Gestionar la animación de intro
    document.addEventListener('DOMContentLoaded', () => {
      const introContainer = document.getElementById('intro-container');
      const controlButtons = document.getElementById('control-buttons');
      
      setTimeout(() => {
        introContainer.style.display = 'none';
        controlButtons.style.opacity = '1';
      }, 4000);
    });

    // Función para obtener el video activo actual
    function getActiveVideo() {
      if (!activeVideoId) {
        for (let i = 0; i < configs.length; i++) {
          const targetEl = document.querySelector(`a-entity[mindar-image-target="targetIndex: ${i}"]`);
          if (targetEl && targetEl.object3D.visible) {
            activeVideoId = configs[i].vidId;
            break;
          }
        }
      }
      return activeVideoId ? document.getElementById(activeVideoId) : null;
    }

    // Función para actualizar estados de botones según el video actual
    function updateButtonStates() {
      const activeVideo = getActiveVideo();
      if (!activeVideo) return;

      const playPauseBtn = document.getElementById('play-pause-btn');
      playPauseBtn.innerHTML = activeVideo.paused ? 
        '<i class="fas fa-play"></i>' : 
        '<i class="fas fa-pause"></i>';

      const muteBtn = document.getElementById('mute-btn');
      muteBtn.innerHTML = activeVideo.muted ? 
        '<i class="fas fa-volume-mute"></i>' : 
        '<i class="fas fa-volume-up"></i>';
    }

    // Manejadores para los botones de control
    document.getElementById('play-pause-btn').addEventListener('click', function() {
      const activeVideo = getActiveVideo();
      if (!activeVideo) return;

      if (activeVideo.paused) {
        activeVideo.play();
        this.innerHTML = '<i class="fas fa-pause"></i>';
      } else {
        activeVideo.pause();
        this.innerHTML = '<i class="fas fa-play"></i>';
      }
    });

    document.getElementById('restart-btn').addEventListener('click', function() {
      const activeVideo = getActiveVideo();
      if (!activeVideo) return;
      
      activeVideo.currentTime = 0;
      activeVideo.play();
      document.getElementById('play-pause-btn').innerHTML = '<i class="fas fa-pause"></i>';
    });

    document.getElementById('mute-btn').addEventListener('click', function() {
      const activeVideo = getActiveVideo();
      if (!activeVideo) return;
      
      activeVideo.muted = !activeVideo.muted;
      this.innerHTML = activeVideo.muted ? 
        '<i class="fas fa-volume-mute"></i>' : 
        '<i class="fas fa-volume-up"></i>';
    });
  </script>
</body>
</html>
